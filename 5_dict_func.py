### СЛОВАРИ (DICT) ###
dict1 = {}  # создаем пустой словарь
dict2 = {'table': 'стол', 2: 'стол'}  #  создаем словарь с данными
# В словарях допускается наличие одинаковых значений
# но при попытке создания словаря с одинаковыми ключами сохранится последнее значение.
dict3 = {'table': 'стол', 'table': 'тоже стол'}

# Создание при помощи функции
phones_dict = dict(Иван='558996', Сергей='529863')
# Данный способ создания словаря подходит только при использовании строк в качестве ключей.
# Альтернативным способом создания словаря с помощью функции dict является создание словаря с помощью списка кортежей.
phones2 = dict([('Егор',  545678), ('Артем', 877645)])

# Создание с помощью метода словарей fromkeys
price = dict.fromkeys(['apple', 'orange'])
# >>>price
# {'apple': None, 'orange': None}
price = dict.fromkeys(['apple', 'orange'], 200)
# >>>price
# {'apple': 200, 'orange': 200}
price = dict.fromkeys(['apple', 'orange'], [200, 300])
# >>>price
#  {'apple': [200, 300], 'orange': [200, 300]}

# С помощью генераторов словарей
square = {item: item ** 2 for item in [0, 1, 2, 3, 4, 5]}
# square {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

dict.keys()  # получаем список ключей
dict.values()  # получаем список значений

dict1.get(4, 'Если ключ не найден, выдастся это сообщение. Если сообщения нет, то None')

# Метод pop удлаяет пару ключ-значение (по ключу) и возвращает значение
price.pop('apple')
# Можно вернуть ключ-значение, тогда надо использовать метод popitem
price.popitem('apple')

# Метод update добавляет к текущему словарю значения из другого словаря. Если ключи совпадают, то значение будет из того, откуда обновляем
price.update({'samsung': 200})
price.update(dict1)


### МНОЖЕСТВА (SET) ###
# контейнер с неповторяющимися элементами в СЛУЧАЙНОМ порядке
# Создавать пустое множество можно только так:
a= set()
# Можно использовать генераторы, можно через set
a = set('hello')